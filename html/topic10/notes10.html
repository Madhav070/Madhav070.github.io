<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="common.css">
    <title>Memory Managment</title>
</head>
<body>
    <div>
        <h1>Structures</h1>
        <p>We have already learnt in the previous tutorials that variables store one piece of information and arrays of certain data types store the information of the same data type. Variables and arrays can handle a great variety of situations. But quite often, we have to deal with the collection of dissimilar data types. For dealing with cases where there is a requirement to store dissimilar data types, C provides a data type called ‘structure’. It is a way to group together information belonging to different data types and combine them into one structure.
        </p><br><br>
        <h3>What are structures in C ?</h3>
        <p>Structures are usually used when we wish to store data of different data types together.
            <br>
            For example, if we want to store information about a book, there could be a number of parameters defining a book. <br>
            Books have a title, an author name, the number of pages, and a price. All of the book attributes belong to different data types. The titles and author names must be strings, but the prices and number of pages must be numerical. <br>
            <br>
            One way to store the data is to construct individual arrays, and another method is to use a structure variable. It is to keep in mind that structure elements are always stored in contiguous memory locations.
        </p><br>
        <h3>Creating a struct element</h3>
        <p>Basic syntax for declaring a struct is, <br>
            struct structure_name <br>
            { <br>
                //structure_elements <br>
            } structure_variable; <br>
            <br>
             
            Here’s one example of how a struct is defined and used in main as a user-defined data type. <br>
            #include < stdio.h > <br>
            <br>
            struct Books <br>
            { <br>
                char title[20]; <br>
                char author[100]; <br>
                float price; <br>
                int pages; <br>
            }; <br>
             <br>
            int main() <br>
            { <br>
                struct Books book1; <br>
                return 0; <br>
            }
        </p><br>
        <h3>Accessing struct elements</h3>
        <p>We use the subscript operator, ‘[‘ fed with the index number to access individual elements of an array. But in the case of structures, to access any element, we use the dot operator (.). This dot operator is coded between the structure variable name and the structure member that we wish to access. <br>
            Before the dot operator, there must always be an already defined structure variable and after the dot operator, there must always be a valid structure element. <br>
              <br>
            Here’s one example demonstrating how we access struct elements. <br>
            #include < stdio.h > <br>
             <br>
            struct Books <br>
            { <br>
                char title[20]; <br>
                char author[100]; <br>
                float price; <br>
                int pages; <br>
            }; <br>
              <br>
            int main() <br>
            { <br>
                struct Books book1 = {"C Programming", "ABC", 123.99, 300}; <br>
                printf("%s\n", book1.title); <br>
                printf("%s\n", book1.author); <br>
                printf("%f\n", book1.price); <br>
                printf("%d\n", book1.pages); <br>
                return 0; <br>
            } <br>

            Output: <br>
            C Programming <br>
            ABC <br>
            123.989998 <br>
            300
        </p><br>
        <h3>Additional features of Structs</h3>
        <ol>
            <li>We can assign the values of a structure variable to another structure variable of the same type using the assignment operator.
            </li><br>
            <li>Structure can be nested within another structure which means structures can have their members as structures themselves.
            </li><br>
            <li>We can pass the structure variable to a function. We can pass the individual structure elements or the entire structure variable into the function as an argument. And functions can also return a structure variable. 
            </li><br>
            <li>We can have a pointer pointing to a struct just like the way we can have a pointer pointing to an int, or a pointer pointing to a char variable.
            </li><br>
        </ol>
        <h3>Where are structs useful ?</h3>
        <ol>
            <li>Structures are used to store a large amount of data of varying data types.
            </li><br>
            <li>They are used to send data to the printer.
            </li><br>
            <li>For placing the cursor at an appropriate position on the screen, we can use structure.
            </li><br>
            <li>It can be used in drawing and floppy formatting.
            </li><br>
            <li>We use structures in finding out the list of equipment attached to the computer.
            </li><br>
        </ol><br><br>
        <h2>Unions</h2>
        <p>Just like Structures, the union is a user-defined data type.  All the members in unions share the same memory location. The union is a data type that allows different data belonging to different data types to be stored in the same memory locations. One of the advantages of using a union is that it provides an efficient way of reusing the memory location, as only one of its members can be accessed at a time. A union is used in the same way we declare and use a structure. The difference lies just in the way memory is allocated to their members.
        </p><br>
        <h3>Defining a Union</h3>
        <p>The syntax for defining a union is, <br>
            union union_name <br>
            { <br>
                //union_elements <br>
            } structure_variable; <br>
            <br>
             
            Here’s one example of how a union is defined and used in main as a user defined data type. <br>
            #include < stdio.h > <br>
             <br>
            union Books <br>
            { <br>
                char title[20]; <br>
                char author[100]; <br>
                float price; <br>
                int pages; <br>
            }; <br>
              <br>
            int main() <br>
            { <br>
                union Books book1; <br>
                return 0; <br>
            } <br>
            <br>
        </p><br>
        <h3>Initialising and accessing union elements</h3>
        <p>Different from how we used to initialise a struct in one single statement, union elements are initialised one at a time. <br>
            <br>
            And also, one can access only one union element at a time. Altering one union element disturbs the value stored in other union elements. <br>
            #include < stdio.h > <br>
            #include < string.h > <br>
             <br>
            union Books <br>
            { <br>
                char title[20]; <br>
                char author[100]; <br>
                float price; <br>
                int pages; <br>
            }; <br>
              <br>
            int main() <br>
            { <br>
                union Books book1; <br>
                strcpy(book1.title, "C  Programming"); <br>
                printf("%s\n", book1.title); <br>
              <br>
                strcpy(book1.author, "ABC"); <br>
                printf("%s\n", book1.author); <br>
             <br>
                book1.price = 123.99; <br>
                printf("%f\n", book1.price); <br>
             <br>
                book1.pages = 300; <br>
                printf("%d\n", book1.pages); <br>
             <br>
                return 0; <br>
            } <br>
            <br>
            Output: <br>
            C Programming <br>
            ABC <br>
            123.989998 <br>
            300
        </p><br>
        <h3>How are Structs and Unions similar?</h3>
        <ol>
            <li>Structures and unions, both are user-defined data types used to store data of different types.
            </li><br>
            <li>Within a structure, each member is allocated a unique storage area of location whereas memory allocated to a union is shared by individual members of the union.
            </li><br>
            <li>Individual members can be accessed at a time in structures whereas only one member can be accessed at a time in unions.
            </li><br>
            <li>Changing the value of one of the members of a structure will not affect the values of the other members of the structure, whereas changing the value of one of the members of a union will affect the values of other members in a union.
            </li><br>
            <li>Several members of a structure can be initialised at once, whereas only one member can be initialised in the union.
            </li><br>
        </ol>
        <h2>Typedef</h2>
        <p>In C programming, a typedef declaration is used to create shorter and more meaningful and convenient to use names for keywords already defined by C like int, float, and char.
        </p><br>
        <h3>What is a typedef in C?
        </h3>
        <p>A typedef is a keyword that is used to assign alternative names to existing datatypes. We use typedef with user defined datatypes, when the names of the datatypes become slightly complicated to use in programs. Typedefs can be used to:
        </p>
        <ul>
            <li>Make a more complex definition reusable by abbreviating it to something less complex.
            </li><br>
            <li>Provide more clarity to the code
            </li><br>
            <li>Make it easier to change the underlying data types that we use
            </li><br>
            <li>Make the code more clear and easier to modify.
            </li><br>
        </ul>
        <p>Following is the syntax for using typedef, <br>
            typedef < previous_name > < alias_name > <br>
            <br>
             
            For example, we would often want to create a variable of type unsigned long. But, then it becomes a complex task if that need to declare an unsigned long comes for multiple variables. To overcome this problem, we use a typedef keyword.  <br>
            Here is how we use it. <br>
            #include < stdio.h > <br>
            typedef unsigned long ul; <br>
            <br>
            int main() <br>
            { <br>
                ul a; <br>
            }
        </p><br>
        <h3>Applications of Typedef</h3>
        <p>There are various applications of typedef. Listed below are a few applications of typedef.
        </p><br>
        <ul>
            <li>The typedef can be used with arrays, primarily multi-dimensional arrays. It increase the readability of the program.
            </li><br>
            <li>Typedefs can also be implemented for defining a user-defined data type like structs or unions with a specific name and type.
            </li><br>
        </ul>
        <p>Here’s how we use typedefs for defining a struct in C. <br>
            typedef struct <br>
            { <br>
                structure element1; <br>
                structure element2; <br> 
                structure element3; <br>
            } name_of_type  <br>
            <br>
            typedef can be used for providing a pseudo name to pointer variables as well. <br>
            typedef int *ptr;
        </p><br>
        <h3>Advantages of Typedef</h3>
        <ul>
            <li>Typedef, as mentioned, increases the readability of the code. If we are using structure or function pointer or long keywords repeatedly in our code, then using typedefs increases the readability of code.
            </li><br>
            <li>With the help of typedef, we can use the same name for different applications even in different scopes.
            </li><br>
            <li>In the case of structure, if we use the typedef then we do not require to write struct keyword at the time of variable declaration.
            </li><br>
            <li>Typedef increases the portability of the code.
            </li><br>
        </ul>




